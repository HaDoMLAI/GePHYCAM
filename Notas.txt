La aplicación contiene los siguientes botones:

- Empatica server (dis)connect: Sirve para establecer la conexión con el servidor de Empatica. Lo he añadido por si algún día se nos ocurre poner el servidor en otro ordenador y añadir la funcionalidad de configurar IP y puerto. 
- Refresh: Los nombres de los dispositivos disponibles se los pido al servidor de empatica. Este botón solo sirve para volver a solicitar la lista.
- (Dis)Connect: sirve para (des)conectarse al dispositivo seleccionado el el comboBox.
- Start/stop: Para iniciar y parar la visualización.

Todo esto lo he creado en funcion de estados y procesando la información recibida del Servidor de Empatica.

Cabe señalar:
- Permite ajustar el tamaño de la ventana.
- Permite modificar el tamaño de las ventanas incluso cuando se esta graficando.
- El logger imprime una serie de mensajes variando el color y/o formato:
	- Las tramas de fallos se escriben en rojo.
	- Las tramas de informacion se escriben en el color normal
	- Las tamas de entrada y salida con el Servidor de empatica se escriben en verde y añadiendo ('<' '>') al principio de la trama en función de si es de entrada o de salida respectivamete.
- El logger cuando alcanza el maximo tamaño y crea el scroll, se coloca siempre en la última línea
- El set user y el load script no estan contempados en los estados, ya que me falta entenderlo bien. Sería algo que hay que probar.

NOTA: la graficación de GSR y TMP no pude ser más suave debido a que la frecuencia de muestreo es de 4HZ y eso si lo percibe el ojo humano como intervalos de pausa.

A continuación añado algunas notas interesantes sobre alguno de los módulos. Intento resumir lo más relevante.

####################################################################
QTDESIGNER
####################################################################
A la interfaz generada no le aplico ninguna hoja de estilo. La hoja de estilo está creada en un fichero aparte (style.css) dentro de la carpeta QTDesigner.

La hoja de estilos la cargo dentro del modulo biosignals_GUI. Aunque esta hoja de estilos no se genera el qwtPlotCanvas porque da error (al ser widgets de terceros), asi que el estilo del canvas lo genero en una función aparte dentro del mismo modulo.

Por otra parte en biosignals_GUI se inicializan los qwtPlotCurves de las señales, de este modo, no hay que realizar modificaciones sobre el fichero creado por pyuic5.exe, nada más que subir el import que se crea debajo del fichero y modificarle el nombre.

####################################################################
DATA MANAGER
####################################################################
Ya no va a implementar el log, puesto que el que se encarga de imprimir en la consola va a ser el propio metodo run() del hilo TCP_IP_COM y la aplicación biosignals a través de Biosignals_GUI.

Se implementa dentro el propio buffer para el ploteo, ya que asi evito tener que crear las mismas funciones en dos modulos diferentes. Se ha unificado los dos buffers (El de los bloques y el suavizado) dentro del mismo, pero permite añadir los bloques de datos e ir adquiriendo los datos para que la graficación sea suave. 

Este buffer almacena los datos ya parseados como numeros y no las tramas en formato texto. Ya que antes el parseo se realizaba antes de plotear (en la función update) lo que implica parsear las mismas tramas varias veces.

Además este buffer permite añadir un tiempo máximo de delay permitido antes de que el buffer se resetee (Yo lo he puesto en 10 segundos). Al resetearse el buffer comienza a pintar desde un array vacio.

También incorpora la funcionalidad de establecer cuantos datos ha de devolver el getSamples, el cual se actualiza cuando se modifica el tamaño de ventana en la interfaz.

El data_manager tambien establece la frecuencia a la que se debe ejecutar la tarea de graficación (update). Esto se debe a una serie de problemas que mencionaré más adelante. Se ha establecido una frecuencia máxima de 24Hz, cuando la señal tiene una frecuencia de muestreo mayor, se baja dicha velocidad de graficación adquiriendo más de una muestra para el suavizado cada vez que se llama a get_samples.

Para poder recuperarse de pequeños retardos (menores al delay máximo) cada vez que hay retardo se coge una muestra más.

####################################################################
PREPROCESSING
####################################################################
La extraccion de datos de la trama se procesa trama tras trama ya que se va a llamar cada vez que se recibe una por el sock.

Además añade otras funciones para la extracción de información de los mensajes que recibimos a través de empatica.

####################################################################
LOG
####################################################################
Como he mencionado ahora se cambia de color y formato los testos que se imprimen en el loguer. Por lo que tenemos cuatro metodos:

- myprint: Texto normal.
- myprint_in: Entrada desde el servidor de empatica ('< '+Testo) en color verde.
- myprint_out: Salida hacia el servidor de empatica ('> '+Testo) en color verde.
- myprint_error: Texto en color rojo.

####################################################################
COMMUNICATION_SIGNALS
####################################################################
Es un modulo nuevo que crea nuevas señales para cuando se reciben tramas referentes a la conexión, pausa, subscripcion y lista de dispositivos. Permitiendo así realizar los cambios de estado dentro de la aplicación principal. El módulo se llama communication_signals.py y está dentro de la carpeta COM ya que hace referencia a las tramas que recibimos a través del socker.

Destaco que lo realice en un modulo aparte ya que TCP_IP_COM implementa Threading.Thread y necesitaba tener un objeto QObject. Como se están usando eventos de Threading no quise cambiarlo a QThread, pero quizás en un futuro se pueda cambiar e implemetar este modulo dentro de TCP_IP_COM.

####################################################################
TCP_IP_COM
####################################################################
Como ya he mencionado antes, se encarga de analizar la información recibida de las tramas y de enviar las señales respectivas a la aplicación principal.

Además cada vez que recibe una trama de datos la parsea y la añade al datamanager correspondiente.

####################################################################
BIOSIGNALS_GUI
####################################################################
Como he mencionado contiene los metodos de inicialización de las qwtPlotCurves y los estilos de la interfaz.

Es donde se crea el log que se le pasa como atributo a TCP_IP_COM.

Los data managents se crean en el biosignals_GUI ya que utiliza valores de los spinbox y simplifica las funciones a crear. lo devuelvo a la app principal (BIOSIGNALS) con un funcion getDmgs. Además es un array que contiene a los cuatro.

El start y stop de las tareas de graficación se implementa en este módulo. Señalar que el start inicialmente resetea los buffer de los data_manager por si se ejecuta el start más de una vez.

####################################################################
PROBLEMAS Y SOLUCIÓN
####################################################################
El problema estaba en que siempre existía retardo en la señal BVP y en menor grado en la señal ACC. Por lo que continuamente se iba reiniciando el buffer (por el delay máximo de 10 segundos). Quizás este problema sea más severo en mi ordenador ya que es bastante lento. 

Entre documentarrme y realizar distintas pruebas decidí medir tiempos de ejecución de las tareas de update de graficación y el tiempo real que transcurría entre las recursibas llamadas a la función update. Y me di cuenta de dos cosas:

1 PROBLEMA: el tiempo de ejecución dentro de los updates sobrepasa la totalidad de tiempo que ha de transcurrir entre las llamadas a la función por el timer para la señal BVP (64Hz). Esto provoca que no quepan el resto de los Timers (gsr,tmp y acc) entre las llamadas de del Timer de BVP. No obtante, las llamadas que se pierden en mayor grado son las de esta señal y en menos grado las de ACC. Tmp y gsr al tener un refresco de 4Hz consigue ejecutar todas las llamadas. Dicho de otra manera, no hay tiempo disponible para que se produzcan todas las llamadas a los Timers con esos periodos.

Dentro de las fuciones de update se ejecutan tres funciones:
	- getSample: que obtiene los datos del buffer de la señal pero el tiempo de ejecución nunca supera los 0.5 milisegundos (depende de la señal ya que por la frecuencia de muestreo pueden contener más o menos muestras y además el ACC contiene tres señales). Este tiempo es bastante pequeño.
	- setData: que es el que agrega los datos a qwtPlotCurve correspondiente tarda entre 10 y 12 milisegundos para todas las señales menos para acc que supera los 20 milisegundos. Este tiempo es el que agrava considerablemente la situacion teniendo en cuenta que el tiempo de timer del BVP es de 15,625 milisegundos.
	- update: que refresca la graficación tarda en ejecutarse entre 7 y 8 milisegundos.

2 PROBLEMA: iterar sobre la ventana o simplemente mover el ratón sobre la misma provoca que se produzcan señales de QT que son atendidas por el codigo de la misma. Esto provoca que se esté utilizando más tiempo y los retardos se agraven.


Para intentar encontrar una solución busco en primer lugar disminuir los tiempos de ejecución dentro de cada interrupción del timer. Esto lo consigo al desactivar los autoreplots de los qwtPlots. Ya que el tiempo de ejecución dentro del la interrupción de Timer se reduce entre los 9 y 12 milisegunndos.

Como ya no abarca la totalidad del periodo de graficación pero si más de la mitad del de BVP y además sigue presente el 2 PROBLEMA, creo dentro de los datamanager una restricción de que la frecuencia máxima de muestreo sea de 24 HZ (que no es muy mala para el ojo humano), y que las frecuencias de muestreo que superen dicho umbral obtengas más de un sample en el getSample y obtenga una frecuencia de muestreo acorde a la cantidad de muestras que coge (siendo el máximo esos 24 HZ). Esto me da las siguientes cantidades de muestras cogidas (nGet) y frecuencias de graficación (freqTask) para cada una de las señales:

Signal	| nGet	|freqTask (Hz)
------------------------------------
BVP		|3		|21.33333
GSR		|1		|4
TMP		|1		|4
ACC		|2		|16

Con todo esto no volví a tener el problema de reseteo aún cuando cambiaba el tamaño de ventana a lo loco y velozmente (que es lo que comprobe produce el retardo más severo) y aun así me tenia que tirar un buen rato. Y además vi que se recuperaba bien de los retardos producidos.


